-- The core class of the project
-- Represents the entire website, storing questions, answers, comments, users, etc.

class StackOverflow
	types
		public String = seq of char;
	values
	instance variables	
		-- App's users
		public users : map nat to User := {|->};
		-- Posted questions
		public questions : map nat to Question := {|->};
		-- Posted answers
		public answers : map nat to Answer := {|->}; 
		-- Posted comments
		public comments : map nat to Comment := {|->};
		-- Votes on posts
		public votes : set of Vote := {};
		-- Started
		public busy : bool := true;
		-- GUI
    public static graphics : gui_Graphics:= new gui_Graphics(); 
    -- Someone is logged in
		public loggedUser : [User] := nil;
	operations
		
		/**
		*	Default Constructor
		*/
		public StackOverflow : () ==> StackOverflow
		StackOverflow () == (
				busy := true;
		);
		
		/**
		*	Create New User
		* @pre username and password not null
		* @pre user not registered already
		*/
		public signup : String * String ==> ()
		signup(username, password) == (
			users := users munion { card dom users |-> new User(username, password) };
		)
		pre (
			username <> "" 
			and password <> ""
			and forall user in set rng users & user.username <> username
		);
		
		/**
		*	Login with credentials
		* @pre username and password not null
		* @pre user exists
		* @pre no one logged in yet
		* @post log-in happens
		* @post logged user is a user
		*/
		public login : String * String ==> ()
		login(username, password) == (
			for all user in set rng users do(
				if (user.username = username and user.password = password) then (
					loggedUser := user;
				)
			);
		)
		pre (
			username <> ""
			and password <> ""
			and exists1 user in set rng users & user.username = username and user.password = password
			and loggedUser = nil
		)
		post (
			loggedUser <> nil
			and loggedUser in set rng users
		);
		
		/**
		*	Log out of the app
		* @pre someone is logged in
		* @post no one is logged in
		*/
		public logout : () ==> ()
		logout() == (
			loggedUser := nil;
		)
		pre loggedUser <> nil
		post loggedUser = nil;
		
		/**
		* Get the logged user's ID
		* @pre someone is logged in
		* @pre logged user is a user
		* @post nothing happens to logged user
		*/
		public getLoggedID : () ==> nat
		getLoggedID() == (
			return (inverse (users :> {loggedUser}))(loggedUser);
		)
		pre (
			loggedUser <> nil
			and loggedUser in set rng users
		)
		post (
			card dom (users :> {loggedUser}) = 1
		);
				
		/**
		*	User asks question
		* @pre contents not null
		* @pre must be logged in
		* @post question is posted
		*/
		public askQuestion : String*String*String ==> ()
		askQuestion(question, description, category) == (
			-- update questions (create question)
			questions := questions munion { card dom questions |-> new Question(getLoggedID(), question, description, category) };
			-- update user's questions
			loggedUser.addQuestion((card dom questions) - 1);
		)
		pre ( 
			question <> ""
			and loggedUser <> nil
			and loggedUser in set rng users
		)
		post (
			card dom questions = card dom questions~ + 1
			--card loggedUser.questions = card loggedUser.questions~ + 1;
		);
		
		/**
		*	User asks question
		* @pre contents not null
		* @pre user is logged in
		* @post @question is posted
		*/
		public askQuestion : String*String ==> ()
		askQuestion(question, description) == (
			-- update questions (create question)
			questions := questions munion { card dom questions |-> new Question(getLoggedID(), question, description) };
			-- update user's questions
			loggedUser.addQuestion((card dom questions) - 1);
		)
		pre ( 
			question <> ""
			and loggedUser <> nil
			and loggedUser in set rng users
		)
		post (
			card dom questions = card dom questions~ + 1
			--card loggedUser.questions = card loggedUser.questions~ + 1;
		);
		
		
		/**
		*	User asks question
		* @pre contents not null
		* @pre user is logged in
		* @post @question is posted
		*/
		public askQuestion : String ==> ()
		askQuestion(question) == (
			-- update questions (create question)
			questions := questions munion { card dom questions |-> new Question(getLoggedID(), question) };
			-- update user's questions
			loggedUser.addQuestion((card dom questions) - 1);
		)
		pre ( 
			question <> ""
			and loggedUser <> nil
			and loggedUser in set rng users
		)
		post (
			card dom questions = card dom questions~ + 1
			--card loggedUser.questions = card loggedUser.questions~ + 1;
		);
		
		
		/**
		*	User Deletes (Own) Question, + related answers and comments
		* @pre user is logged in
		* @pre question exists
		* @pre question was posted by logged-in user
		* @post question is no more
		* @post question is deleted (toggle)
		*/
		public deleteQuestion : nat ==> ()
		deleteQuestion(questionID) == (
			questions(questionID).delete();
			loggedUser.questions := loggedUser.questions \ {questionID};
			for all aID in set questions(questionID).answers do (
				answers(aID).delete();
				questions(answers(aID).questionID).answers := questions(answers(aID).questionID).answers \ {aID};
				for all cID in set answers(aID).comments do (
					comments(cID).delete();
					answers(aID).comments := answers(aID).comments \ {cID};
				)
			)
		)
		pre (
			loggedUser <> nil
			and questionID < card dom questions
			and exists1 question in set dom questions & question = questionID
			and questionID in set loggedUser.questions
		)
		post (
			card dom questions = card dom questions~
		  and	questions(questionID).deleted = true
			-- card loggedUser.questions = card loggedUser.questions~ -1;
		);
		
		/**
		*	User edits (own) question
		* @pre user is logged in
		* @pre question exists
		* @pre question not closed
		* @pre question cntents not null
		* @pre question posted by logged user
		*/
		public editQuestion : nat*String*String ==> ()
		editQuestion(questionID, question, desc) == (
			questions(questionID).edit(question, desc);
		)
		pre (
			loggedUser <> nil
			and questionID < card dom questions
			and question <> ""
			and exists1 qid in set dom questions & qid = questionID
			and questionID in set loggedUser.questions
			and questions(questionID).closed = false
		);
		
		/**
		*	User Answers Question
		* @pre user is logged in
		* @pre question exists
		* @pre contents not null
		* @post answer is posted
		*/
		public answerQuestion : nat*String ==> ()
		answerQuestion(questionID, answer) == (
			answers := answers munion {card dom answers |-> new Answer(getLoggedID(), questionID, answer) };
			questions(questionID).answer((card dom answers) -1);
		)
		pre (
			loggedUser <> nil
			and questionID < card dom questions
			and answer <> ""
			and exists1 qid in set dom questions & qid = questionID
		)
		post (
			card dom answers = card dom answers~ + 1
			-- and questions(questionID).answers = questions(questionID).answers~ + 1
		);
				
		/**
		*	User Deletes (Own) Answer and related comments
		* @pre user is logged in
		* @pre answer exists
		* @post answer is deleted
		*/
		public deleteAnswer : nat ==> ()
		deleteAnswer(answerID) == (
			if (answers(answerID).userID = getLoggedID()) then answers(answerID).delete();
			questions(answers(answerID).questionID).answers := questions(answers(answerID).questionID).answers \ {answerID};
			for all cID in set answers(answerID).comments do comments(cID).delete();
		)
		pre (
			loggedUser <> nil
			and answerID < card dom answers
			and exists1 answer in set dom answers & answer = answerID
		)
		post (
			card dom answers = card dom answers~
			and answers(answerID).deleted = true
		);
		
		/**
		*	User Edits Answer
		* @pre user is logged in
		* @pre answer exists
		* @pre contents not null
		* @post answer still posted
		*/
		public editAnswer : nat*String ==> ()
		editAnswer(answerID, content) == (
			if (answers(answerID).userID = getLoggedID()) then answers(answerID).edit(content);
		)
		pre (
			loggedUser <> nil
			and content <> ""
			and answerID < card dom answers
			and exists1 answer in set dom answers & answer = answerID
		)
		post (
			card dom answers = card dom answers~
		);
		
		/**
		*	User Accepts answer
		* @pre user is logged in
		* @pre answer exists
		* @pre question exists
		* @pre question not closed
		* @pre no answer accepted
		* @post question is closed
		* @post answer is accepted
		*/
		public acceptAnswer : nat*nat ==> ()
		acceptAnswer(questionID, answerID) == (
			answers(answerID).accept();
			questions(questionID).close();
		) 
		pre (
			loggedUser <> nil
			and questionID < card dom questions
			and answerID < card dom answers
			and exists1 question in set dom questions & question = questionID
			and exists1 answer in set dom answers & answer = answerID
			and answers(answerID).questionID = questionID
			and not questions(questionID).closed
			and forall aID in set questions(questionID).answers & not answers(aID).accepted
		) 
		post (
			questions(questionID).closed
			and answers(answerID).accepted
		);
		
		/**
		*	User Comments an Answer
		* @pre user is logged in
		* @pre answer exists
		* @pre question not closed or deleted
		* @post comment posted
		*/
		public commentAnswer : nat*nat*String ==> ()
		commentAnswer(questionID, answerID, content) == (
			comments := comments munion { card dom comments |-> new Comment(getLoggedID(), questionID, answerID, content) };
			answers(answerID).comment((card dom comments) - 1);
		)
		pre (
			content <> ""
			and loggedUser <> nil
			and questionID < card dom questions
			and answerID < card dom answers
			and exists1 question in set dom questions & question= questionID
			and exists1 answer in set dom answers & answer = answerID
			and not (questions(questionID).closed or questions(questionID).deleted)
		)
		post (
			card dom comments = card dom comments~ + 1
			--and card answers(answerID).comments = card answers(answerID).comments~ + 1
		);
		
		/**
		*	User Comments a Question
		* @pre user is logged in
		* @pre question exists
		* @pre answer exists
		* @pre question not closed or deleted
		* @post comment posted
		*/
		public commentQuestion : nat*String ==> ()
		commentQuestion(questionID, content) == (
			comments := comments munion { card dom comments |-> new Comment(getLoggedID(), questionID, -1, content) };
			questions(questionID).comment((card dom comments) - 1);
		)
		pre (
			content <> ""
			and loggedUser <> nil
			and questionID < card dom questions
			and exists1 question in set dom questions & question = questionID
			and not (questions(questionID).closed or questions(questionID).deleted)
		)
		post (
			card dom comments = card dom comments~ + 1
		);
		
		/**
		*	User Deletes a comment
		* @pre user is logged in
		* @pre comment exists
		* @post comment deleted
		*/
		public deleteComment : nat ==> ()
		deleteComment(commentID) == (
			if (comments(commentID).userID = getLoggedID()) then (
				comments(commentID).delete();
				answers(comments(commentID).answerID).comments := answers(comments(commentID).answerID).comments \ {commentID};
			)		
		)
		pre (
			loggedUser <> nil
			and commentID < card dom comments
			and exists1 comment in set dom comments & comment = commentID
		)
		post (
			comments(commentID).deleted = true
		);
		
		/**
		*	User Edits comment
		* @pre user is logged in
		* @pre comment exists
		* @pre contents not null
		* @post comment posted
		*/		
		public editComment : nat*String ==> ()
		editComment(commentID, content) == (
			if (comments(commentID).userID = getLoggedID()) then (
				comments(commentID).edit(content);
			)
		)
		pre (
			loggedUser <> nil
			and commentID < card dom comments
			and exists1 comment in set dom comments & comment = commentID
			and len content > 0
		)
		post(
			card dom comments = card dom comments~ 
		);
		
		/**
		*	User upvotes question
		* @pre user is logged
		* @pre question not his own
		* @pre question not deleted
		* @pre not voted already by user
		* @post vote is posted
		*/
		public upvoteQuestion : nat ==> ()
		upvoteQuestion(questionID) == (
			votes := votes union {new Upvote(0,getLoggedID(),questionID)};
		)
		pre (
			loggedUser <> nil
			and not questions(questionID).userID = (inverse (users :> {loggedUser}))(loggedUser)
			and exists1 question in set dom questions & question = questionID
			and not questions(questionID).deleted
			and not exists1 vote in set votes & (
				isofclass(Vote, vote)
				and vote.userID = (inverse (users :> {loggedUser}))(loggedUser)
				and vote.questionID = questionID
			)
		)
		post(
			card votes = card votes~ + 1
		);
		
		/**
		*	User downvotes question
		* @pre user is logged
		* @pre question not his own
		* @pre question not deleted
		* @pre not voted already by user
		* @post vote is posted
		*/
		public downvoteQuestion : nat ==> ()
		downvoteQuestion(questionID) == (
			votes := votes union {new Downvote(0,getLoggedID(),questionID)};
		)
		pre (
			loggedUser <> nil
			and not questions(questionID).userID = (inverse (users :> {loggedUser}))(loggedUser)
			and exists1 question in set dom questions & question = questionID
			and not questions(questionID).deleted
			and not exists1 vote in set votes & (
				isofclass(Vote, vote)
				and vote.userID = (inverse (users :> {loggedUser}))(loggedUser)
				and vote.questionID = questionID
			)
		)
		post(
			card votes = card votes~ + 1
		);
	
		/**
		*	User upvotes answer
		* @pre user is logged
		* @pre answer not his own
		* @pre answer not deleted
		* @pre not voted already by user
		* @post vote is posted
		*/
		public upvoteAnswer : nat ==> ()
		upvoteAnswer(answerID) == (
			votes := votes union {new Upvote(1,getLoggedID(),answerID)};
		)
		pre (
			loggedUser <> nil
			and not answers(answerID).userID = (inverse (users :> {loggedUser}))(loggedUser)
			and exists1 answer in set dom answers & answer = answerID
			and not answers(answerID).deleted
			and not exists1 vote in set votes & (
				isofclass(Vote, vote)
				and vote.userID = (inverse (users :> {loggedUser}))(loggedUser)
				and vote.answerID = answerID
			)
		)
		post(
			card votes = card votes~ + 1
		);
		
		/**
		*	User downvotes answer
		* @pre user is logged
		* @pre answer not his own
		* @pre answer not deleted
		* @pre not voted already by user
		* @post vote is posted
		*/
		public downvoteAnswer : nat ==> ()
		downvoteAnswer(answerID) == (
			votes := votes union {new Downvote(1,getLoggedID(),answerID)};
		)
		pre (
			loggedUser <> nil
			and not answers(answerID).userID = (inverse (users :> {loggedUser}))(loggedUser)
			and exists1 answer in set dom answers & answer = answerID
			and not answers(answerID).deleted
			and not exists1 vote in set votes & (
				isofclass(Vote, vote)
				and vote.userID = (inverse (users :> {loggedUser}))(loggedUser)
				and vote.answerID = answerID
			)
		)
		post(
			card votes = card votes~ + 1
		);
		
		/**
		*	User upvotes comment
		* @pre user is logged
		* @pre comment not his own
		* @pre comment not deleted
		* @pre not voted already by user
		* @post vote is posted
		*/
		public upvoteComment : nat ==> ()
		upvoteComment(commentID) == (
			votes := votes union {new Upvote(2,getLoggedID(),commentID)};
		)
		pre (
			loggedUser <> nil
			and not comments(commentID).userID = (inverse (users :> {loggedUser}))(loggedUser)
			and exists1 comment in set dom comments & comment = commentID
			and not comments(commentID).deleted
			and not exists1 vote in set votes & (
				isofclass(Vote, vote)
				and vote.userID = (inverse (users :> {loggedUser}))(loggedUser)
				and vote.commentID = commentID
			)
		)
		post(
			card votes = card votes~ + 1
		);
		
	  /**
		*	User downvotes answer
		* @pre user is logged
		* @pre comment not his own
		* @pre comment not deleted
		* @pre not voted already by user
		* @post vote is posted
		*/
		public downvoteComment : nat ==> ()
		downvoteComment(commentID) == (
			votes := votes union {new Downvote(2,getLoggedID(),commentID)};
		)
		pre (
			loggedUser <> nil
			and not comments(commentID).userID = (inverse (users :> {loggedUser}))(loggedUser)
			and exists1 comment in set dom comments & comment = commentID
			and not comments(commentID).deleted
			and not exists1 vote in set votes & (
				isofclass(Vote, vote)
				and vote.userID = (inverse (users :> {loggedUser}))(loggedUser)
				and vote.commentID = commentID
			)
		)
		post(
			card votes = card votes~ + 1
		);
		
		/**
		*	Get votes on a given post
		* @pre inputs in bounds
		*/
		public getVotes : nat*nat*nat ==> nat
		getVotes(updown, type, postID) == (
			dcl a : nat := 0;
			cases updown :
				-- upvote
				0 ->	cases type:
								-- question
								0 ->	(for all vote in set votes do (if (isofclass(Upvote, vote) and vote.questionID = postID) then a := a + 1 )),
								-- answer
								1 -> 	(for all vote in set votes do (if (isofclass(Upvote, vote) and vote.answerID = postID) then a := a + 1 )),
								-- comment
								2 ->	(for all vote in set votes do (if (isofclass(Upvote, vote) and vote.commentID = postID) then a := a + 1 ))
							end,
				-- downvote
				1 -> cases type:
								-- question
								0 ->	(for all vote in set votes do (if (isofclass(Downvote, vote) and vote.questionID = postID) then a := a + 1 )),
								-- answer
								1 -> 	(for all vote in set votes do (if (isofclass(Downvote, vote) and vote.answerID = postID) then a := a + 1 )),
								-- comment
								2 ->	(for all vote in set votes do (if (isofclass(Downvote, vote) and vote.commentID = postID) then a := a + 1 ))
							end
			end;
			return a;
		)
		pre (
			(updown = 0 or updown = 1)
			and type < 3
		);
		
		
		/**
		*	Print to the console the users
		*/
		public printUsers : () ==> ()
		printUsers () == (
			for all user in set rng users do (
				Printer`Out("User - " ^ user.username ^ "\n" ^ "Questions: \n ");
				for all qID in set user.questions do (
					Printer`Out("\tQ"^Printer`natToString(qID) ^ ":\n\tCategory: " ^ questions(qID).category ^ "\n\tQuestion: " ^ questions(qID).text ^ "\n\tDesc: " ^ questions(qID).description ^"\n");
				) 
			)
		);
		
		/**
		* Print Questions, Answers and Comments to the console
		*/
		public printQuestions : () ==> ()
		printQuestions () == (
			for all qID in set dom questions do (
				Printer`Out("Q"^Printer`natToString(qID) ^ 
										":\nCategory: " ^ questions(qID).category ^ 
										"\nQuestion: " ^questions(qID).text ^ 
										"\nDescription: " ^ questions(qID).description ^ 
										"\nDate: " ^ questions(qID).date ^ 
										"\nVotes: " ^ Printer`natToString(getVotes(0, 0, qID)) ^ " Upvotes & " ^ Printer`natToString(getVotes(1,0,qID)) ^ " Downvotes\n" ^
										"\nComments:\n" );
										
				for all cID in set questions(qID).comments do (
						Printer`Out("\tC"^Printer`natToString(cID) ^
											"\n\tcomment by " ^ users(comments(cID).userID).username ^
											"\n\tcomment: " ^ comments(cID).text ^
											"\n\tdate: " ^ comments(cID).date ^
											"\nVotes: " ^ Printer`natToString(getVotes(0, 2, cID)) ^ " Upvotes & " ^ Printer`natToString(getVotes(1,2,cID)) ^ " Downvotes\n" ^
											"\n");
				);
				
				if (card questions(qID).answers = 0) then Printer`Out("\tNo answers yet!\n")
				else Printer`Out("\nAnswers:\n");
				
				for all aID in set questions(qID).answers do (
					Printer`Out("\tA"^Printer`natToString(aID) ^
											"\n\tanswered by " ^ users(answers(aID).userID).username ^
											"\n\tanswer: " ^ answers(aID).text ^
											"\n\tdate: " ^ answers(aID).date ^
											"\nVotes: " ^ Printer`natToString(getVotes(0, 1, aID)) ^ " Upvotes & " ^ Printer`natToString(getVotes(1,1,aID)) ^ " Downvotes\n" ^
											"\n\tComments:\n" );
					
					if (card answers(aID).comments = 0) then Printer`Out("\t\t No comments yet!\n");			
											
					for all cID in set answers(aID).comments do (
						Printer`Out("\tC"^Printer`natToString(cID) ^
											"\n\t\tcomment by " ^ users(comments(cID).userID).username ^
											"\n\t\tcomment: " ^ comments(cID).text ^
											"\n\t\tdate: " ^ comments(cID).date ^
											"\nVotes: " ^ Printer`natToString(getVotes(0, 2, cID)) ^ " Upvotes & " ^ Printer`natToString(getVotes(1,2,cID)) ^ " Downvotes\n" ^
											"\n");
					);
				)
				
			)
		)
		
	functions
	traces
end StackOverflow